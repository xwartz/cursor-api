// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.27.1
// source: message.proto

import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export interface ChatMessage {
  /** repeated FileContent files = 1; */
  messages: ChatMessage_UserMessage[];
  instructions: ChatMessage_Instructions | undefined;
  projectPath: string;
  model: ChatMessage_Model | undefined;
  requestId: string;
  /** 或许是空的，描述会话做了什么事情，但是不是标题 或许可以当作额外的设定来用 */
  summary: string;
  /** 又来一个uuid */
  conversationId: string;
}

export interface ChatMessage_FileContent {
  filename: string;
  content: string;
  position: ChatMessage_FileContent_Position | undefined;
  language: string;
  range: ChatMessage_FileContent_Range | undefined;
  length: number;
  type: number;
  errorCode: number;
}

export interface ChatMessage_FileContent_Position {
  line: number;
  column: number;
}

export interface ChatMessage_FileContent_Range {
  start: ChatMessage_FileContent_Position | undefined;
  end: ChatMessage_FileContent_Position | undefined;
}

export interface ChatMessage_UserMessage {
  content: string;
  role: number;
  messageId: string;
}

export interface ChatMessage_Instructions {
  instruction: string;
}

export interface ChatMessage_Model {
  name: string;
  empty: string;
}

export interface ResMessage {
  msg: string;
}

function createBaseChatMessage(): ChatMessage {
  return {
    messages: [],
    instructions: undefined,
    projectPath: "",
    model: undefined,
    requestId: "",
    summary: "",
    conversationId: "",
  };
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(message: ChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      ChatMessage_UserMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.instructions !== undefined) {
      ChatMessage_Instructions.encode(message.instructions, writer.uint32(34).fork()).join();
    }
    if (message.projectPath !== "") {
      writer.uint32(42).string(message.projectPath);
    }
    if (message.model !== undefined) {
      ChatMessage_Model.encode(message.model, writer.uint32(58).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(74).string(message.requestId);
    }
    if (message.summary !== "") {
      writer.uint32(90).string(message.summary);
    }
    if (message.conversationId !== "") {
      writer.uint32(122).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(ChatMessage_UserMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instructions = ChatMessage_Instructions.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.projectPath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.model = ChatMessage_Model.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage_UserMessage.fromJSON(e))
        : [],
      instructions: isSet(object.instructions) ? ChatMessage_Instructions.fromJSON(object.instructions) : undefined,
      projectPath: isSet(object.projectPath) ? globalThis.String(object.projectPath) : "",
      model: isSet(object.model) ? ChatMessage_Model.fromJSON(object.model) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChatMessage_UserMessage.toJSON(e));
    }
    if (message.instructions !== undefined) {
      obj.instructions = ChatMessage_Instructions.toJSON(message.instructions);
    }
    if (message.projectPath !== "") {
      obj.projectPath = message.projectPath;
    }
    if (message.model !== undefined) {
      obj.model = ChatMessage_Model.toJSON(message.model);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {
    const message = createBaseChatMessage();
    message.messages = object.messages?.map((e) => ChatMessage_UserMessage.fromPartial(e)) || [];
    message.instructions = (object.instructions !== undefined && object.instructions !== null)
      ? ChatMessage_Instructions.fromPartial(object.instructions)
      : undefined;
    message.projectPath = object.projectPath ?? "";
    message.model = (object.model !== undefined && object.model !== null)
      ? ChatMessage_Model.fromPartial(object.model)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.summary = object.summary ?? "";
    message.conversationId = object.conversationId ?? "";
    return message;
  },
};

function createBaseChatMessage_FileContent(): ChatMessage_FileContent {
  return {
    filename: "",
    content: "",
    position: undefined,
    language: "",
    range: undefined,
    length: 0,
    type: 0,
    errorCode: 0,
  };
}

export const ChatMessage_FileContent: MessageFns<ChatMessage_FileContent> = {
  encode(message: ChatMessage_FileContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.position !== undefined) {
      ChatMessage_FileContent_Position.encode(message.position, writer.uint32(26).fork()).join();
    }
    if (message.language !== "") {
      writer.uint32(42).string(message.language);
    }
    if (message.range !== undefined) {
      ChatMessage_FileContent_Range.encode(message.range, writer.uint32(50).fork()).join();
    }
    if (message.length !== 0) {
      writer.uint32(64).int32(message.length);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.errorCode !== 0) {
      writer.uint32(88).int32(message.errorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage_FileContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage_FileContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = ChatMessage_FileContent_Position.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.range = ChatMessage_FileContent_Range.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.errorCode = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage_FileContent {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      position: isSet(object.position) ? ChatMessage_FileContent_Position.fromJSON(object.position) : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      range: isSet(object.range) ? ChatMessage_FileContent_Range.fromJSON(object.range) : undefined,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      errorCode: isSet(object.errorCode) ? globalThis.Number(object.errorCode) : 0,
    };
  },

  toJSON(message: ChatMessage_FileContent): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.position !== undefined) {
      obj.position = ChatMessage_FileContent_Position.toJSON(message.position);
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.range !== undefined) {
      obj.range = ChatMessage_FileContent_Range.toJSON(message.range);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.errorCode !== 0) {
      obj.errorCode = Math.round(message.errorCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage_FileContent>, I>>(base?: I): ChatMessage_FileContent {
    return ChatMessage_FileContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage_FileContent>, I>>(object: I): ChatMessage_FileContent {
    const message = createBaseChatMessage_FileContent();
    message.filename = object.filename ?? "";
    message.content = object.content ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? ChatMessage_FileContent_Position.fromPartial(object.position)
      : undefined;
    message.language = object.language ?? "";
    message.range = (object.range !== undefined && object.range !== null)
      ? ChatMessage_FileContent_Range.fromPartial(object.range)
      : undefined;
    message.length = object.length ?? 0;
    message.type = object.type ?? 0;
    message.errorCode = object.errorCode ?? 0;
    return message;
  },
};

function createBaseChatMessage_FileContent_Position(): ChatMessage_FileContent_Position {
  return { line: 0, column: 0 };
}

export const ChatMessage_FileContent_Position: MessageFns<ChatMessage_FileContent_Position> = {
  encode(message: ChatMessage_FileContent_Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line !== 0) {
      writer.uint32(8).int32(message.line);
    }
    if (message.column !== 0) {
      writer.uint32(16).int32(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage_FileContent_Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage_FileContent_Position();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.line = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.column = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage_FileContent_Position {
    return {
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
    };
  },

  toJSON(message: ChatMessage_FileContent_Position): unknown {
    const obj: any = {};
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage_FileContent_Position>, I>>(
    base?: I,
  ): ChatMessage_FileContent_Position {
    return ChatMessage_FileContent_Position.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage_FileContent_Position>, I>>(
    object: I,
  ): ChatMessage_FileContent_Position {
    const message = createBaseChatMessage_FileContent_Position();
    message.line = object.line ?? 0;
    message.column = object.column ?? 0;
    return message;
  },
};

function createBaseChatMessage_FileContent_Range(): ChatMessage_FileContent_Range {
  return { start: undefined, end: undefined };
}

export const ChatMessage_FileContent_Range: MessageFns<ChatMessage_FileContent_Range> = {
  encode(message: ChatMessage_FileContent_Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      ChatMessage_FileContent_Position.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      ChatMessage_FileContent_Position.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage_FileContent_Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage_FileContent_Range();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.start = ChatMessage_FileContent_Position.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.end = ChatMessage_FileContent_Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage_FileContent_Range {
    return {
      start: isSet(object.start) ? ChatMessage_FileContent_Position.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? ChatMessage_FileContent_Position.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: ChatMessage_FileContent_Range): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = ChatMessage_FileContent_Position.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = ChatMessage_FileContent_Position.toJSON(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage_FileContent_Range>, I>>(base?: I): ChatMessage_FileContent_Range {
    return ChatMessage_FileContent_Range.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage_FileContent_Range>, I>>(
    object: I,
  ): ChatMessage_FileContent_Range {
    const message = createBaseChatMessage_FileContent_Range();
    message.start = (object.start !== undefined && object.start !== null)
      ? ChatMessage_FileContent_Position.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null)
      ? ChatMessage_FileContent_Position.fromPartial(object.end)
      : undefined;
    return message;
  },
};

function createBaseChatMessage_UserMessage(): ChatMessage_UserMessage {
  return { content: "", role: 0, messageId: "" };
}

export const ChatMessage_UserMessage: MessageFns<ChatMessage_UserMessage> = {
  encode(message: ChatMessage_UserMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    if (message.messageId !== "") {
      writer.uint32(106).string(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage_UserMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage_UserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage_UserMessage {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
    };
  },

  toJSON(message: ChatMessage_UserMessage): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage_UserMessage>, I>>(base?: I): ChatMessage_UserMessage {
    return ChatMessage_UserMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage_UserMessage>, I>>(object: I): ChatMessage_UserMessage {
    const message = createBaseChatMessage_UserMessage();
    message.content = object.content ?? "";
    message.role = object.role ?? 0;
    message.messageId = object.messageId ?? "";
    return message;
  },
};

function createBaseChatMessage_Instructions(): ChatMessage_Instructions {
  return { instruction: "" };
}

export const ChatMessage_Instructions: MessageFns<ChatMessage_Instructions> = {
  encode(message: ChatMessage_Instructions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instruction !== "") {
      writer.uint32(10).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage_Instructions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage_Instructions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instruction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage_Instructions {
    return { instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : "" };
  },

  toJSON(message: ChatMessage_Instructions): unknown {
    const obj: any = {};
    if (message.instruction !== "") {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage_Instructions>, I>>(base?: I): ChatMessage_Instructions {
    return ChatMessage_Instructions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage_Instructions>, I>>(object: I): ChatMessage_Instructions {
    const message = createBaseChatMessage_Instructions();
    message.instruction = object.instruction ?? "";
    return message;
  },
};

function createBaseChatMessage_Model(): ChatMessage_Model {
  return { name: "", empty: "" };
}

export const ChatMessage_Model: MessageFns<ChatMessage_Model> = {
  encode(message: ChatMessage_Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.empty !== "") {
      writer.uint32(34).string(message.empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage_Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage_Model();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.empty = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage_Model {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      empty: isSet(object.empty) ? globalThis.String(object.empty) : "",
    };
  },

  toJSON(message: ChatMessage_Model): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.empty !== "") {
      obj.empty = message.empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage_Model>, I>>(base?: I): ChatMessage_Model {
    return ChatMessage_Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage_Model>, I>>(object: I): ChatMessage_Model {
    const message = createBaseChatMessage_Model();
    message.name = object.name ?? "";
    message.empty = object.empty ?? "";
    return message;
  },
};

function createBaseResMessage(): ResMessage {
  return { msg: "" };
}

export const ResMessage: MessageFns<ResMessage> = {
  encode(message: ResMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== "") {
      writer.uint32(10).string(message.msg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResMessage {
    return { msg: isSet(object.msg) ? globalThis.String(object.msg) : "" };
  },

  toJSON(message: ResMessage): unknown {
    const obj: any = {};
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResMessage>, I>>(base?: I): ResMessage {
    return ResMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResMessage>, I>>(object: I): ResMessage {
    const message = createBaseResMessage();
    message.msg = object.msg ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
